import psycopg2


class DBController:
    def __init__(self, connection_params: dict):
        self.connection = None
        self.cursor = None
        self.table_names = {}  # autogenerated using name as {name: name_name}
        self.connection_params = connection_params

    def create_connection(self):
        try:
            self.connection = psycopg2.connect(
                host=self.connection_params['host'],
                database=self.connection_params['database'],
                user=self.connection_params['user'],
                port=self.connection_params['port'],
                password=self.connection_params['password'])
            self.cursor = self.connection.cursor()
        except Exception as err:
            print(f'Error: {err}')

    def create_page_names_table(self, table_name: str):
        """Creates table (id, page_name, page_link)"""
        if self.is_table_absent(table_name):
            self.cursor.execute(f'CREATE TABLE {table_name} (\
                    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,\
                    title VARCHAR(256) UNIQUE NOT NULL\
            );')
            self.cursor.execute(f'CREATE UNIQUE INDEX title_idx ON {table_name} (id, title);')
            self.connection.commit()

    def create_m2m_relations_table(self, table_name: str) -> None:
        """Creates Many-to-Many relation table, rely on 'id'"""
        # check if tables for relations are exist
        if self.is_table_absent(table_name):
            print(f"Error: Can't create relational table: {table_name} does not exist")
            return
        # creating many_to_many (self-to-self) relational table if absent
        self.table_names[table_name] = f'{table_name}_{table_name}'
        if self.is_table_absent(self.table_names[table_name]):
            self.cursor.execute(f'CREATE TABLE {self.table_names[table_name]} (\
                    parent_id INTEGER NOT NULL,\
                    child_id INTEGER,\
                    FOREIGN KEY (parent_id)\
                        REFERENCES {table_name} (id)\
                        ON UPDATE CASCADE ON DELETE CASCADE,\
                    FOREIGN KEY (child_id)\
                        REFERENCES {table_name} (id)\
                        ON UPDATE CASCADE ON DELETE CASCADE,\
                    CONSTRAINT parent_child_unique UNIQUE (parent_id, child_id)\
            );')
            self.cursor.execute(f'CREATE UNIQUE INDEX id_idx ON {self.table_names[table_name]}'
                                f' (parent_id, child_id);')
            self.connection.commit()

    def is_table_absent(self, table_name: str) -> bool:
        self.cursor.execute(f"SELECT EXISTS("
                            f"SELECT relname FROM pg_class "
                            f"WHERE relname = '{table_name}');")
        return not self.cursor.fetchone()[0]

    def get_page(self, table_name: str, title: str) -> tuple[int] | None:
        self.cursor.execute(f"SELECT id FROM {table_name} WHERE title = %s", (title,))
        return self.cursor.fetchone()

    def is_link_cashed(self, table_name: str, link_id: int) -> tuple[int] | None:
        self.cursor.execute(f"SELECT EXISTS("
                            f"SELECT parent_id FROM {self.table_names[table_name]} "
                            f"WHERE parent_id = %s);", (link_id,))
        return self.cursor.fetchone()

    def get_link_if_cached(self, table_name: str, title: str) -> tuple[int] | None:
        # print(f'{table_name=} {title=} ')
        self.cursor.execute(f"SELECT parent_id FROM {self.table_names[table_name]} "
                            f"WHERE parent_id IN("
                            f"SELECT id FROM {table_name} WHERE title = %s"
                            f")", (title,))
        return self.cursor.fetchone()

    def get_title_links(self, table_name: str, page_id: int) -> list[tuple[int], tuple[str]]:
        self.cursor.execute(f"SELECT id, title FROM {table_name} WHERE id IN ("
                            f"SELECT child_id FROM {self.table_names[table_name]} "
                            f"WHERE parent_id = %s)", (page_id,))
        return self.cursor.fetchall()

    def cache_pages_relations(self, table_name: str, parent_id: str, children_ids: list):
        """Stores page names and uris in links table and creates Many-to-Many relations'"""
        # prepare relation table name and dict of all links taken
        children = [(child,) for child in children_ids]
        parent = (parent_id,)
        all_links = (parent, *children)

        # fill links table with links
        query = f"INSERT INTO {table_name}(title) " \
                f"VALUES (%s) " \
                f"ON CONFLICT DO NOTHING;"

        self.cursor.executemany(query, all_links)
        self.connection.commit()

        # get id generated by DB
        self.cursor.execute(f"SELECT id FROM {table_name} WHERE title = %s", parent)
        parent_id = self.cursor.fetchone()[0]

        # if children exist in page
        if children:
            # get id's of children generated by DB (if they exist in page)
            self.cursor.execute(f"SELECT id FROM {table_name} WHERE title IN %s", (tuple(children),))
            children_ids = self.cursor.fetchall()

            # preparing list of pairs parent_id, child_id to put in DB
            relations = [(parent_id, child_id[0]) for child_id in children_ids]

            # fill many_to_many (self-to-self) relations table
            query = f"INSERT INTO {self.table_names[table_name]}(parent_id, child_id) " \
                    f"VALUES (%s, %s) " \
                    f"ON CONFLICT DO NOTHING"
            self.cursor.executemany(query, relations)
            self.connection.commit()

        # -----TEST-----
        # query = f"DELETE FROM {table_name} " \
        #         f"WHERE id = 1 "
        # self.cursor.executemany(query, relations)
        # self.connection.commit()
        return parent_id

    def prepare_connection(self, table_name: str):
        if not self.cursor or self.cursor.closed:
            self.create_connection()
        self.table_names[table_name] = f'{table_name}_{table_name}'

    def get_most_popular_titles(self, table_name: str, amount: int) -> list[tuple[str, int]]:
        self.prepare_connection(table_name)

        query = f"SELECT " \
                f"(SELECT title FROM {table_name} WHERE {table_name}.id = parent_id), count(child_id) co " \
                f"FROM {self.table_names[table_name]} "\
                f"WHERE child_id IN " \
                f"(SELECT parent_id FROM {self.table_names[table_name]})" \
                f"GROUP BY parent_id " \
                f"ORDER BY co DESC " \
                f"LIMIT {amount}"
        self.cursor.execute(query)
        most_popular_titles = self.cursor.fetchall()
        self.cursor.close()
        self.connection.close()
        return most_popular_titles

    def get_titles_with_most_links(self, table_name: str, amount: int) -> list[tuple[str, int]]:
        self.prepare_connection(table_name)

        query = f"SELECT " \
                f"(SELECT title FROM {table_name} WHERE {table_name}.id = parent_id), count(child_id) co " \
                f"FROM {self.table_names[table_name]} "\
                f"WHERE child_id != parent_id " \
                f"GROUP BY parent_id " \
                f"ORDER BY co DESC " \
                f"LIMIT {amount}"
        self.cursor.execute(query)

        titles_with_most_links = self.cursor.fetchall()
        self.cursor.close()
        self.connection.close()
        return titles_with_most_links

    def get_average_link_number_for_deep_2(self, table_name: str, title: str) -> list:
        self.prepare_connection(table_name)

        query = f"SELECT ROUND(AVG(links)) FROM (SELECT count(child_id) AS links " \
                f"FROM {self.table_names[table_name]} "\
                f"WHERE parent_id in (" \
                f"  SELECT child_id FROM {self.table_names[table_name]} " \
                f"  WHERE parent_id = " \
                f"      (SELECT id FROM {table_name} WHERE {table_name}.title = %s)) " \
                f"GROUP BY parent_id) as link_numbers_table"
        self.cursor.execute(query, (title,))

        titles_with_most_links = self.cursor.fetchone()
        self.cursor.close()
        self.connection.close()
        return titles_with_most_links

