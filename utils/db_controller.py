import psycopg2


class DBController:
    def __init__(self):
        self.connection = None
        self.cursor = None
        self.table_names = {}  # autogenerated as {name: name_name}

    def create_connection(self,
                          host: str,
                          database: str,
                          user: str,
                          port: int,
                          password: str
                          ):
        try:
            self.connection = psycopg2.connect(
                host=host,
                database=database,
                user=user,
                port=port,
                password=password)
            self.cursor = self.connection.cursor()
        except Exception as err:
            print(f'Error: {err}')

    def create_page_names_table(self, table_name: str):
        """Creates table (id, page_name, page_link)"""
        if self.is_table_absent(table_name):
            self.cursor.execute(f'CREATE TABLE {table_name} (\
                    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,\
                    title VARCHAR(256) UNIQUE NOT NULL\
            );')
            self.cursor.execute(f'CREATE UNIQUE INDEX title_idx ON {table_name} (id, title);')
            self.connection.commit()

    def create_m2m_relations_table(self, table_name: str) -> None:
        """Creates Many-to-Many relation table, rely on 'id'"""
        # check if tables for relations are exist
        if self.is_table_absent(table_name):
            print(f"Error: Can't create relational table: {table_name} does not exist")
            return
        # creating many_to_many (self-to-self) relational table if absent
        self.table_names[table_name] = f'{table_name}_{table_name}'
        if self.is_table_absent(self.table_names[table_name]):
            self.cursor.execute(f'CREATE TABLE {self.table_names[table_name]} (\
                    parent_id INTEGER NOT NULL,\
                    child_id INTEGER,\
                    FOREIGN KEY (parent_id)\
                        REFERENCES {table_name} (id)\
                        ON UPDATE CASCADE ON DELETE CASCADE,\
                    FOREIGN KEY (child_id)\
                        REFERENCES {table_name} (id)\
                        ON UPDATE CASCADE ON DELETE CASCADE,\
                    CONSTRAINT parent_child_unique UNIQUE (parent_id, child_id)\
            );')
            self.cursor.execute(f'CREATE UNIQUE INDEX id_idx ON {self.table_names[table_name]}'
                                f' (parent_id, child_id);')
            self.connection.commit()

    def is_table_absent(self, table_name: str) -> bool:
        self.cursor.execute(f"SELECT EXISTS("
                            f"SELECT relname FROM pg_class "
                            f"WHERE relname = '{table_name}');")
        return not self.cursor.fetchone()[0]

    def get_page(self, table_name: str, title: str) -> tuple[int] | None:
        self.cursor.execute(f"SELECT id FROM {table_name} WHERE title = %s", (title,))
        return self.cursor.fetchone()

    def is_link_cashed(self, table_name: str, link_id: int) -> tuple[int] | None:
        self.cursor.execute(f"SELECT EXISTS("
                            f"SELECT parent_id FROM {self.table_names[table_name]} "
                            f"WHERE parent_id = %s);", (link_id,))
        return self.cursor.fetchone()

    def get_link_if_cached(self, table_name: str, title: str) -> tuple[int] | None:
        # print(f'{table_name=} {title=} ')
        self.cursor.execute(f"SELECT parent_id FROM {self.table_names[table_name]} "
                            f"WHERE parent_id IN("
                            f"SELECT id FROM {table_name} WHERE title = %s"
                            f")", (title,))
        return self.cursor.fetchone()

    def get_related_pages(self, table_name: str, page_id: int) -> list[tuple[int], tuple[str]]:
        self.cursor.execute(f"SELECT id, title FROM {table_name} WHERE id IN ("
                            f"SELECT child_id FROM {self.table_names[table_name]} "
                            f"WHERE parent_id = %s)", (page_id,))
        return self.cursor.fetchall()

    def cache_pages_relations(self, table_name: str, parent_id: str, children_ids: list):
        """Stores page names and uris in links table and creates Many-to-Many relations'"""
        # prepare relation table name and dict of all links taken
        children = [(child,) for child in children_ids]
        parent = (parent_id,)
        all_links = (parent, *children)

        # fill links table with links
        query = f"INSERT INTO {table_name}(title) " \
                f"VALUES (%s) " \
                f"ON CONFLICT DO NOTHING;"

        self.cursor.executemany(query, all_links)
        self.connection.commit()

        # get id generated by DB
        self.cursor.execute(f"SELECT id FROM {table_name} WHERE title = %s", parent)
        parent_id = self.cursor.fetchone()[0]

        # if children exist in page
        if children:
            # get id's of children generated by DB (if they exist in page)
            self.cursor.execute(f"SELECT id FROM {table_name} WHERE title IN %s", (tuple(children),))
            children_ids = self.cursor.fetchall()

            # preparing list of pairs parent_id, child_id to put in DB
            relations = [(parent_id, child_id[0]) for child_id in children_ids]

            # fill many_to_many (self-to-self) relations table
            query = f"INSERT INTO {self.table_names[table_name]}(parent_id, child_id) " \
                    f"VALUES (%s, %s) " \
                    f"ON CONFLICT DO NOTHING"
            self.cursor.executemany(query, relations)
            self.connection.commit()

        # -----TEST-----
        # query = f"DELETE FROM {table_name} " \
        #         f"WHERE id = 1 "
        # self.cursor.executemany(query, relations)
        # self.connection.commit()
        return parent_id
